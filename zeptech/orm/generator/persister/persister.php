<?php
namespace zeptech\dynamic\orm\persister;

use \zeptech\orm\runtime\ActorFactory;
use \zeptech\orm\runtime\Criteria;
use \zeptech\orm\runtime\Persister;
use \zeptech\orm\runtime\PdoExceptionWrapper;
use \zeptech\orm\runtime\PdoWrapper;
use \zeptech\orm\runtime\SaveLock;
use \zeptech\orm\QueryBuilder;
use \Exception;
use \PDO;
use \PDOException;

/**
 * This is a persister class generated by Clarinet.  Do NOT modify this file.
 * Instead, modify the model class of this persister, then run the clarinet
 * generator to re-generate this file.
 */
class ${actor} {

  /**
   * Entities that in the process of being created are marked with this id so
   * that any right side relationships won't call the create method for the
   * entity a second time.  In particular this will help prevent double creation
   * when saving a mirrored ManyToOneEntity.  This happens because the left side
   * (many side) of the relationship will attempt to create the right side, if
   * it doesn't have an id, before the left side entity has been assigned an id.
   * So the right side persister will see that the left side has a null id and
   * will create it a second time.  So setting an entities id to this marker
   * will let a right side persister know not to re-create or update the entity.
   */
  const CREATE_MARKER = 0;

  /*
   * Delete entities will have an index in the cache but the value will be
   * null.
   */
  private $_cache = array();

  /* PDO Connection to the database in which entities are to be persisted. */
  private $_pdo = null;

  /* PDOStatement for inserting new entities into the database */
  private $createSql;
  private $_create = null;

  /* PDOStatement for updating existing entities. */
  private $updateSql;
  private $_update = null;

  /* PDOStatement for deleting existing entities. */
  private $deleteSql;
  private $_delete = null;

  /**
   * Create a new persister for ${class} entities.
   */
  public function __construct() {
    $this->_pdo = PdoWrapper::get();

    $this->createSql =
      "INSERT INTO ${table}
       (${join:column_names:,})
       VALUES
       (${join:value_names:,})";
    $this->_create = $this->_pdo->prepare($this->createSql);

    ${if:has_update}
      $this->updateSql = 
        "UPDATE ${table}
         SET ${join:sql_setters:,}
         WHERE ${id_column} = :id";
      $this->_update = $this->_pdo->prepare($this->updateSql);
    ${else}
      $this->_update = null;
    ${fi}

    $this->deleteSql = "DELETE FROM ${table} WHERE ${id_column} = :id";
    $this->_delete = $this->_pdo->prepare($this->deleteSql);
  }

  /**
   * Clear the cache. If an id is provided, only the entity with the given id
   * is cleared.  This will happen when an entity at the many side of an
   * un-mirrored one-to-many relationship is updated to ensure that it does not
   * have a stale id for the one side of the relationship.  The entire cache is
   * generally only cleared during testing.
   *
   * @param mixed $id
   */
  public function clearCache($id = null) {
    if ($id === null) {
      $this->_cache = array();
    } else {
      unset($this->_cache[$id]);
    }
  }

  /**
   * Return a count of all entities that match the given criteria.
   *
   * @param Criteria $c
   * @return integer
   */
  public function count(Criteria $c) {
    if ($c === null) {
      $c = new Criteria();
    }

    if ($c->getTable() === null) {
      $c->setTable('${table}');
    }


    $c->setDistinct(true) // Ensure each entity is only counted once
      ->selectCount()     // Setup the select list to only select COUNT(*)
      ->setLimit(null);   // Remove any limit on the criteria
    $sql = $c->__toString();
    $params = $c->getParameters();

    try {

      $stmt = $this->_pdo->prepare($sql);
      $stmt->execute($params);

      return (int) $stmt->fetchColumn();
    } catch (PDOException $e) {
      // TODO - Create a PDOExceptionWrapper that parses the error message in
      //        order to present an error suitable for users
      $e = new PdoExceptionWrapper($e, '${class}');
      $e->setSql($sql, $params);
      throw $e;
    }
  }

  /**
   * Insert the given entity into the database.
   *
   * @param ${class} $model
   */
  public function create(\${class} $model) {
    $validator = ActorFactory::getActor('validator', '${class}');
    if (!$validator->validate($model, $e)) {
      throw $e;
    }

    if ($model->get${id_property}() !== null) {
      return $model->get${id_property}();
    }

    ${if:beforeCreate}
      $model->beforeCreate();
    ${fi}

    try {
      $startTransaction = $this->_pdo->beginTransaction();

      $model->set${id_property}(self::CREATE_MARKER);

      $params = Array();
      ${each:properties as prop}

        ${if:prop[type] = boolean}
          $params[':${prop[col]}'] = $model->get${prop[name]}() ? 1 : 0;
        ${else}
          $params[':${prop[col]}'] = $model->get${prop[name]}();
        ${fi}

      ${done}

      ${each:relationships as rel}
        ${if:rel[type] = many-to-one}
          // Populate ${rel[rhs]} parameter
          $rhs = $model->get${rel[lhsProperty]}();
          $rhsId = null;
          if ($rhs !== null) {
            $rhsId = $rhs->get${rel[rhsIdProperty]}();
            if ($rhsId === null) {
              $persister = Persister::get('${rel[rhs]}');
              $rhsId = $persister->create($rhs);
            }
          }
          $params[':${rel[lhsColumn]}'] = $rhsId;
        ${fi}
      ${done}

      $sql = $this->createSql; // If there is an exception this is handy to know
      $this->_create->execute($params);

      $id = $this->_pdo->lastInsertId();
      $model->set${id_property}($id);
      $this->_cache[$id] = $model;

      // TODO Figure out a way of getting sql into any exceptions
      $sql = null;
      $params = null;
      ${each:collections as col}
        $this->insertCollection_${col[property]}($id, $model->get${col[property]}());
      ${done}

      $saveLock = SaveLock::acquire();
      $saveLock->lock($model);

      ${each:relationships as rel}
        // ---------------------------------------------------------------------
        // Save related ${rel[rhs]} entities
        $persister = Persister::get('${rel[rhs]}');
        ${if:rel[type] = many-to-many}
          // If any of the related entities are new, save them to ensure that
          // they have an id, then update them.
          $related = $model->get${rel[lhsProperty]}();
          if ($related !== null) {
            foreach($related AS $rel) {
              if ($rel->get${rhsIdProperty}() === null) {
                $persister->save($rel);
              }
            }
          }

          // Delete all link entries for this entity
          $sql = "DELETE FROM ${rel[linkTable]} WHERE ${rel[lhsLinkColumn]} = :id";
          $params = array('id' => $id);
          $this->_pdo->prepare($sql)->execute($params);

          // Create new link entries for all related entities
          if ($related !== null) {
            $sql = "INSERT INTO ${rel[linkTable]} (${rel[lhsLinkColumn]}, ${rel[rhsLinkColumn]}) VALUES (:lhsId, :rhsId)";
            $createStmt = $this->_pdo->prepare($sql);
            foreach ($related AS $rel) {
              $params = array(
                'lhsId' => $id,
                'rhsId' => $rel->get${rel[rhsIdProperty]}()
              );
              $createStmt->execute($params);
            }
          }

        ${elseif:rel[type] = one-to-many}
          $related = $model->get${rel[lhsProperty]}();
          if ($related === null) {
            $related = array();
          }

          // Update or save the collection
          ${if:rel[mirrored]}
           foreach ($related AS $rel) {
             $rel->set${rel[rhsProperty]}($model);
             $persister->save($model);
           }
          ${else}
            foreach ($related AS $rel) {
              if ($rel->get${rel[rhsIdProperty]}() === null) {
                $persister->create($rel);
              }
            }

            $sql = "UPDATE ${rel[rhsTable]}
                    SET ${rel[rhsColumn]} = :id
                    WHERE ${rel[rhsIdColumn]} = :relId";
            $updateStmt = $this->_pdo->prepare($sql);

            foreach ($related AS $rel) {
              $params = array(
                'id' => $id,
                'relId' => $rel->get${rel[rhsIdProperty]}()
              );
              $updateStmt->execute($params);

              // Clear the cache of the RHS entity as it may contain a stale id
              $persister->clearCache($rel->get${rel[rhsIdProperty]}());
            }
          ${fi}
        ${fi}
        // ---------------------------------------------------------------------
      ${done}

      if ($startTransaction) {
        $this->_pdo->commit();
      }

      $saveLock->release();

      ${if:onCreate}
        $model->onCreate();
      ${fi}

      return $id;
    } catch (PDOException $e) {
      $this->_pdo->rollback();
      $model->set${id_property}(null);

      if (isset($saveLock)) {
        $saveLock->forceRelease();
      }

      $e = new PdoExceptionWrapper($e, '${class}');
      $e->setSql($sql, $params);
      throw $e;
    }
  }

  /**
   * Delete the given entity.
   *
   * @param ${class} $model
   */
  public function delete(\${class} $model) {
    $id = $model->get${id_property}();
    if ($id === null) {
      throw new Exception("Can't delete ${class_str} because it does not have an id");
    }

    $params = array();
    $params[':id'] = $id;

    ${if:beforeDelete}
      $model->beforeDelete();
    ${fi}

    try {
      $startTransaction = $this->_pdo->beginTransaction();

      $sql = $this->deleteSql; // Set SQL in case there is an exception
      $this->_delete->execute($params);
      $rowCount = $this->_delete->rowCount();

      #{ each: collections as col
      ${each:collections as col}
        $this->removeCollection_${col[property]}($id);
      ${done}
      #} each

      ${each:relationships AS rel}
        // ---------------------------------------------------------------------
        // Delete related ${rhs} entities
        ${if:rel[type] = one-to-many}
          $persister = Persister::get('${rel[rhs]}');
          $related = $model->get${rel[lhsProperty]}();
          foreach ($related AS $rel) {
            $persister->delete($rel);
          }

        ${elseif:rel[type] = many-to-many}
          $sql = 'DELETE FROM ${rel[linkTable]} WHERE ${rel[lhsLinkColumn]} = :id';
          $params = array('id' => $id);
          $deleteStmt = $this->_pdo->prepare($sql);
          $deleteStmt->execute($params);

        ${fi}
        // ---------------------------------------------------------------------
      ${done}

      ${if:onDelete}
        $model->onDelete();
      ${fi}

      $this->_cache[$id] = null;
      $model->set${id_property}(null);

      if ($startTransaction) {
        $this->_pdo->commit();
      }

      return $rowCount;
    } catch (PDOException $e) {
      $this->_pdo->rollback();

      $e = new PdoExceptionWrapper($e, '${class}');
      $e->setSql($sql, $params);
      throw $e;
    }
  }

  /**
   * Get the entity with the given id.  If no entity with the given id exists
   * then null is returned.
   *
   * @param integer $id
   * @return ${class}
   */
  public function getById($id) {
    if (!isset($this->_cache[$id])) {
      $c = new Criteria();
      $c->addEquals('${id_column}', $id);

      // We don't care about the result since the retrieve method will
      // populate the cache
      $this->retrieve($c);
      
      if (!isset($this->_cache[$id])) {
        return null;
      }
    }
    return $this->_cache[$id];
  }

  /**
   * Get a new query builder instance for the model handled by this persister.
   *
   * @return QueryBuilder
   */
  public function getQueryBuilder() {
    return QueryBuilder::get('${class}');
  }

  /**
   * Retrieve a single entity that matches the given criteria.  If the criteria
   * results in more than one entity being retrieved then an exception is
   * thrown.  If the criteria results in no entities being retrieved then NULL
   * is returned
   *
   * @param Criteria $c Criteria that will result in a single entity
   * @return ${class}
   * @throws Exception if the criteria results in more than one entity.
   */
  public function retrieveOne(Criteria $c) {
    $entities = $this->retrieve($c);

    $num = count($entities);
    if ($num > 1) {
      throw new Exception("Criteria maps to $num entities, expected 1");
    } else if ($num === 0) {
      return null;
    }

    return $entities[0];
  }

  /**
   * Retrieve entities that match the given criteria.  If no criteria then all
   * entities are returned.  If no entities exist or match the criteria then an
   * empty array is returned.
   *
   * @param Criteria $c
   */
  public function retrieve(Criteria $c = null) {
    if ($c === null) {
      $c = new Criteria();
    }

    if ($c->getTable() === null) {
      $c->setTable('${table}');
    }


    // Clear the selects so that the default of all columns for the FROM table
    // are selected and ensure that only distinct entities are returned
    $c->clearSelects()
      ->setDistinct(true);
    $sql = $c->__toString();
    $params = $c->getParameters();

    try {
      $stmt = $this->_pdo->prepare($sql);
      $stmt->setFetchMode(PDO::FETCH_ASSOC);
      $stmt->execute($params);

      $transformer = ActorFactory::getActor('transformer', '${class}');
      $result = Array();
      foreach ($stmt AS $row) {
        $id = $transformer->idFromDb($row['${id_column}']);

        // Don't allow two instances for the same id to be created
        if (isset($this->_cache[$id])) {
          $result[] = $this->_cache[$id];
          continue;
        }

        $model = new \${class}();
        $model->set${id_property}($id);

        // Cache the instance before populating any relationships in order to
        // prevent inifinite loops when loading models that have a
        // relationship that is declared on both sides
        $this->_cache[$id] = $model;

        // Populate the model's properties
        ${each:properties AS prop}
          ${if:prop[type] = boolean}
            $model->set${prop[name]}($row['${prop[col]}'] == 1 ? true : false);

          ${elseif:prop[type] = integer}
            $model->set${prop[name]}((int) $row['${prop[col]}']);

          ${else}
            $model->set${prop[name]}($row['${prop[col]}']);

          ${fi}
        ${done}

        // Populate collections
        #{ each: collections as col
        // TODO Figure out a way of getting SQL into any exceptions
        $sql = null;
        $params = null;
        ${each:collections as col}
          $this->retrieveCollection_${col[property]}($id, $model);
        ${done}
        #} each

        // Populate any relationships
        ${each:relationships AS rel}
          // -------------------------------------------------------------------
          // Populate the ${rel[rhs]}
          ${if:rel[type] = one-to-many}
            $c = new Criteria();
            $c->addEquals('${rel[rhsColumn]}', $id);
            ${if:rel[orderByCol] ISSET}
              $c->addSort('${rel[orderByCol]}', '${rel[orderByDir]}');
            ${else}
              $c->addSort('${rel[rhsIdProperty]}', 'asc');
            ${fi}

            $persister = Persister::get('${rel[rhs]}');
            $related = $persister->retrieve($c);
            $model->set${rel[lhsProperty]}($related);

          ${elseif:rel[type] = many-to-many}
            $c = new Criteria();
            $c->addSelect('${rel[rhsTable]}.*');
            $c->addJoin('${rel[linkTable]}', '${rel[rhsIdColumn]}', '${rel[rhsLinkColumn]}');
            $c->addEquals('${rel[lhsLinkColumn]}', $id);
            ${if:rel[orderByCol] ISSET}
              $c->addSort('${rel[orderByCol]}', '${rel[orderByDir]}');
            ${fi}

            $persister = Persister::get('${rel[rhs]}');
            $related = $persister->retrieve($c);
            $model->set${rel[lhsProperty]}($related);

          ${elseif:rel[type] = many-to-one}
            $relId = $row['${rel[lhsColumn]}'];
            if ($relId !== null) {
              $persister = Persister::get('${rel[rhs]}');
              $related = $persister->getById($relId);

              if ($related === null) {
                throw new Exception("No ${rel[rhsStr]} with id $relId.");
              }

              $model->set${rel[lhsProperty]}($related);
            }

          ${fi}
          // -------------------------------------------------------------------
        ${done}

        $result[] = $model;
      }

      return $result;
    } catch (PDOException $e) {
      $e = new PdoExceptionWrapper($e, '${class}');
      $e->setSql($sql, $params);
      throw $e;
    }
  }

  /**
   * Saves the given instance by either creating it if it does not have an ID or
   * updating if it does.
   *
   * @param ${class} $model
   */
  public function save(\${class} $model) {
    $id = $model->get${id_property}();
    if ($id === null) {
      $this->create($model);
    } else {
      $this->update($model);
    }
  }

  /**
   * Update the given entity.
   *
   * @param ${class} $model
   */
  public function update(\${class} $model) {
    $id = $model->get${id_property}();
    if ($id === null) {
      throw new Exception("Can't update ${class_str} because it does not have an id");
    }

    if (SaveLock::isLocked($model)) {
      return;
    }

    $validator = ActorFactory::getActor('validator', '${class}');
    if (!$validator->validate($model, $e)) {
      throw $e;
    }

    ${if:beforeUpdate}
      $model->beforeUpdate();
    ${fi}

    try {
      $startTransaction = $this->_pdo->beginTransaction();

      $saveLock = SaveLock::acquire();
      $saveLock->lock($model);

      $params = Array();
      $params[':id'] = $id;
      ${each:properties as prop}
        ${if:prop[type] = boolean}
          $params[':${prop[col]}'] = $model->get${prop[name]}() ? 1 : 0;
        ${else}
          $params[':${prop[col]}'] = $model->get${prop[name]}();
        ${fi}
      ${done}

      ${each:relationships as rel}

        ${if:rel[type] = many-to-one}
          // Populate ${rel[rhs]} parameter
          $rhs = $model->get${rel[lhsProperty]}();
          $rhsId = null;
          if ($rhs !== null) {
            $rhsId = $rhs->get${rel[rhsIdProperty]}();
            if ($rhsId === null) {
              $persister = ActorFactory::getActor('persister', '${rel[rhs]}');
              $rhsId = $persister->create($rhs);
            }
          }
          $params[':${rel[lhsColumn]}'] = $rhsId;
        ${fi}

      ${done}

      ${if:has_update}
        $sql = $this->updateSql;
        $this->_update->execute($params);
        $rowCount = $this->_update->rowCount();
      ${fi}

      #-- Update each of the model's collections by first removing the existing
      #-- persisted collection and replacing it with what is in the model
      #{ each: collections as col
      // TODO Figure out a way of getting the SQL and params into any exception
      $sql = null;
      $params = null;
      ${each:collections as col}
          $this->removeCollection_${col[property]}($id);
          $this->insertCollection_${col[property]}($id, $model->get${col[property]}());
      ${done}
      #} each


      ${each:relationships as rel}
        // ---------------------------------------------------------------------
        // Save related ${rel[rhs]} entities
        $persister = Persister::get('${rel[rhs]}');
        ${if:rel[type] = many-to-many}
          // If any of the related entities are new, save them to ensure that
          // they have an id, then update them.
          $related = $model->get${rel[lhsProperty]}();
          if ($related !== null) {
            foreach($related AS $rel) {
              if ($rel->get${rhsIdProperty}() === null) {
                $persister->save($rel);
              }
            }
          }

          // Delete all link entries for this entity
          $sql = "DELETE FROM ${rel[linkTable]} WHERE ${rel[lhsLinkColumn]} = :id";
          $params = array('id' => $id);
          $deleteStmt = $this->_pdo->prepare($sql);
          $deleteStmt->execute($params);

          // Create new link entries for all related entities
          if ($related !== null) {
            $sql = "INSERT INTO ${rel[linkTable]} (${rel[lhsLinkColumn]}, ${rel[rhsLinkColumn]}) VALUES (:lhsId, :rhsId)";
            $createStmt = $this->_pdo->prepare();
            foreach ($related AS $rel) {
              $params = array(
                'lhsId' => $id,
                'rhsId' => $rel->get${rel[rhsIdProperty]}()
              );
              $createStmt->execute($params);
            }
          }

        ${elseif:rel[type] = one-to-many}
          $related = $model->get${rel[lhsProperty]}();
          if ($related === null) {
            $related = array();
          }

          $relIds = array();
          foreach ($related AS $rel) {
            $relIds[] = $rel->get${rel[rhsIdProperty]}();
          }

          $c = new Criteria();
          $c->addEquals('${rel[rhsColumn]}', $id);
          $current = $persister->retrieve($c);

          // Update or save the collection
          ${if:rel[mirrored]}
            foreach ($related AS $rel) {
              $rel->set${rel[rhsProperty]($model);
              $persister->save($model);
            }
            foreach ($current AS $cur) {
              if (!in_array($cur->get${rel[rhsIdProperty]}(), $relIds)) {
                ${if:rel[deleteOrphan]}
                  $persister->delete($cur);
                ${else}
                  $cur->set${rel[rhsProperty]}(null);
                  $persister->save($cur);
                ${fi}
              }
            }
          ${else}
            foreach ($related AS $rel) {
              if ($rel->get${rel[rhsIdProperty]}() === null) {
                $persister->create($rel);
              }
            }

            $sql = "UPDATE ${rel[rhsTable]} SET ${rel[rhsColumn]} = :id WHERE ${rel[rhsIdColumn]} = :relId";
            $updateStmt = $this->_pdo->prepare($sql);
            foreach ($related AS $rel) {
              $params = array(
                'id' => $id,
                'relId' => $rel->get${rel[rhsIdProperty]}()
              );
              $updateStmt->execute($params);

              // Clear the cache of the RHS entity as it may contain a stale id
              $persister->clearCache($rel->get${rel[rhsIdProperty]}());
            }

            ${if:rel[deleteOrphan]}
              $sql = "DELETE FROM ${rel[rhsTable]} WHERE ${rel[rhsIdColumn]} = :relId";
              $orphanStmt = $this->_pdo->prepare($sql);
            ${else}
              $sql = "UPDATE ${rel[rhsTable]} SET ${rel[rhsColumn]} = null WHERE ${rel[rhsIdColumn]} = :relId";
              $orphanStmt = $this->_pdo->prepare($sql);
            ${fi}
            foreach ($current AS $cur) {
              if (!in_array($cur->get${rel[rhsIdProperty]}(), $relIds)) {
                $params = array('relId' => $cur->get${rel[rhsIdProperty]}());
                $orphanStmt->execute($params);
              }

              $persister->clearCache($rel->get${rel[rhsIdProperty]}());
            }
          ${fi}
        ${fi}
        // ---------------------------------------------------------------------
      ${done}

      $saveLock->release();

      if ($startTransaction) {
        $this->_pdo->commit();
      }

      ${if:onUpdate}
        $model->onUpdate();
      ${fi}

      ${if:has_update}
        return $rowCount;
      ${else}
        return 1;
      ${fi}
      return $rowCount;
    } catch (PDOException $e) {
      $this->_pdo->rollback();
      $saveLock->forceRelease();

      $e = new PdoExceptionWrapper($e, '${class}');
      $e->setSql($sql, $params);
      throw $e;
    }
  }

  #-- Create methods for removing each of the model's collections
  #{ each: collection as col
  ${each:collections as col}
    private function removeCollection_${col[property]}($id) {
      $stmt = $this->_pdo->prepare(
        'DELETE FROM ${col[link]}
         WHERE ${col[idCol]} = :id');
      $stmt->execute(array('id' => $id));
        
    }
  ${done}
  #} done

  #-- Create methods for persisting each of the model's collections
  #{ each: collections as col
  ${each:collections as col}
    private function insertCollection_${col[property]}($id, $collection) {
      ${if:col[type] = set}
      #{ if: col[type] = set
        $stmt = $this->_pdo->prepare(
          "INSERT INTO ${col[link]}
           (${collection[idCol]}, ${col[valCol]})
           VALUES (:id, :val)");

        // TODO Update this to use bulk insert
        foreach ($collection as $val) {
          $stmt->execute(array(
            'id' => $id,
            'val' => $val
          ));
        }

      ${elseif:col[type] = list}
      #} { elseif: col[type] = list
        $stmt = $this->_pdo->prepare(
          "INSERT INTO ${col[link]}
           (${col[idCol]}, ${col[valCol]}, ${col[seqCol]})
           VALUES (:id, :val, :seq)");

        // TODO Update this to use bulk insert
        foreach ($collection as $seq => $val) {
          $stmt->execute(array(
            'id' => $id,
            'val' => $val,
            'seq' => $seq
          ));
        }

      ${elseif:col[type] = map}
      #} { elseif: col[type] = map
        $stmt = $this->_pdo->prepare(
          "INSERT INTO ${col[link]}
           (${col[idCol]}, ${col[keyCol]}, ${col[valCol]})
           VALUES (:id, :key, :val)");

        // TODO Update this to use bulk insert
        foreach ($collection as $key => $val) {
          $stmt->execute(array(
            'id' => $id,
            'key' => $key,
            'val' => $val
          ));
        }

      ${fi}
      #} if
    }
  ${done}
  #} each

  #-- Create methods for retrieve each of the model's collections
  #{ each: collections as col
  ${each: collections as col}
    private function retrieveCollection_${col[property]}($id, $model) {
      #{ if: col[type] = set
      ${if:col[type] = set}
        $stmt = $this->_pdo->prepare(
          'SELECT ${col[valCol]} FROM ${col[link]} WHERE ${col[idCol]} = :id');
        $stmt->execute(array('id' => $id));

        $collection = array();
        foreach ($stmt as $row) {
          $collection[] = $row['${col[valCol]}'];
        }
        $model->set${col[property]}($collection);
        
      #}{ else if: col[type] = list
      ${elseif:col[type] = list}
        $stmt = $this->_pdo->prepare(
          'SELECT ${col[valCol]} FROM ${col[link]} WHERE ${col[idCol]} = :id
           ORDER BY ${col[seqCol]}');
        $stmt->execute(array('id' => $id));
        
        $collection = array();
        foreach ($stmt as $row) {
          $collection[] = $row['${col[valCol]}'];
        }
        $model->set${col[property]}($collection);

      #}{ else if: col[type] = map
      ${elseif:col[type] = map}
        $stmt = $this->_pdo->prepare(
          'SELECT ${col[keyCol]}, ${col[valCol]}
           FROM ${col[link]}
           WHERE ${col[idCol]} = :id');
        $stmt->execute(array('id' => $id));

        $collection = array();
        foreach ($stmt as $row) {
          $collection[$row['${col[keyCol]}']] = $row['${col[valCol]}'];
        }
        $model->set${col[property]}($collection);

      ${fi}
      #} if
    }
  ${done}
  #} each
}
