<?php
namespace /*# companionNs #*/;

use zpt\db\DatabaseConnection;
use \zpt\orm\companion\PersisterBase;
use \zpt\orm\runtime\SaveLock;
use \zpt\orm\PdoExceptionWrapper;
use \zpt\orm\Criteria;
use \Psr\Log\LoggerAwareInterface;
use \Psr\Log\LoggerAwareTrait;
use \Exception;

/**
 * This is a persister class generated by Clarinet.  Do NOT modify this file.
 * Instead, modify the model class of this persister, then run the clarinet
 * generator to re-generate this file.
 */
class /*# companionClass #*/ extends PersisterBase
{

  /**
   * Entities that are in the process of being created are marked with this id
   * so that any right side relationships won't call the create method for the
   * entity a second time.  In particular this will help prevent double creation
   * when saving a mirrored ManyToOneEntity.  This happens because the left side
   * (many side) of the relationship will attempt to create the right side, if
   * it doesn't have an id, before the left side entity has been assigned an id.
   * So the right side persister will see that the left side has a null id and
   * will create it a second time.  So setting an entities id to this marker
   * will let a right side persister know not to re-create or update the entity.
   */
  const CREATE_MARKER = 0;

  private $createSql;
  private $create;
  private $updateSql;
  private $update;
  private $deleteSql;
  private $delete;

  /**
   * Create a new persister for ${class} entities.
   */
  public function __construct(DatabaseConnection $db) {
    parent::__construct($db);

    $columns = /*# php:column_names #*/;

    $escaped = [];
    $params = [];
    $setters = [];
    foreach ($columns as $col) {
      $escapedCol = $this->queryAdapter->escapeField($col);
      $paramName = ":$col";

      $escaped[] = $escapedCol;
      $params[] = $paramName;
      $setters[] = "$escapedCol = $paramName";
    }
    $escapedCols = implode(',', $escaped);
    $paramCols = implode(',', $params);
    $setterClauses = implode(',', $setters);

    $this->createSql =
      "INSERT INTO /*# table #*/ ($escapedCols) VALUES ($paramCols)";
    $this->create = $this->db->prepare($this->createSql);

    #{ if has_update
      $this->updateSql = "UPDATE /*# table #*/
        SET $setterClauses WHERE /*# id_column #*/ = :id";
      $this->update = $this->db->prepare($this->updateSql);
    #}

    $this->deleteSql = "DELETE FROM /*# table #*/ WHERE /*# id_column */ = :id";
    $this->delete = $this->db->prepare($this->deleteSql);
  }

  /**
   * Return a count of all entities that match the given criteria.
   *
   * @param Criteria $c
   * @return integer
   */
  public function count(Criteria $c) {
    if ($c === null) {
      $c = new Criteria($this->queryAdapter);
    }

    if ($c->getTable() === null) {
      $c->setTable('/*# table #*/');
    }


    $c->setDistinct(true) // Ensure each entity is only counted once
      ->selectCount()     // Setup the select list to only select COUNT(*)
      ->setLimit(null);   // Remove any limit on the criteria
    $sql = $c->__toString();
    $params = $c->getParameters();

    $this->logQuery($sql, $params);

    try {

      $stmt = $this->db->prepare($sql);
      $qr = $stmt->execute($params);

      return (int) $qr->fetchColumn();
    } catch (PDOException $e) {
      // TODO - Create a PDOExceptionWrapper that parses the error message in
      //        order to present an error suitable for users
      $e = new PdoExceptionWrapper($e, '/*# class #*/');
      $e->setSql($sql, $params);
      throw $e;
    }
  }

  /**
   * Insert the given entity into the database.
   *
   * @param ${class} $model
   */
  public function create(\/*# class #*/ $model) {
    $validator = $this->getValidator('/*# class #*/');

    if (!$validator->validate($model, $e)) {
      throw $e;
    }

    if ($model->get/*# id_property #*/() !== null) {
      return $model->get/*# id_property #*/();
    }

    #{ if beforeCreate
      $model->beforeCreate();
    #}

    try {
      $startTransaction = $this->db->beginTransaction();

      $model->set/*# id_property #*/(self::CREATE_MARKER);

      $params = Array();
      #{ each properties as prop
        #{ if prop[type] = 'boolean'
          $params['/*# prop[col] #*/'] = $model->get/*# prop[name] #*/() ? 1 : 0;
        #{ else
          $params['/*# prop[col] #*/'] = $model->get/*# prop[name] #*/();
        #}
      #}

      #{ each relationships as rel
        #{ if rel[type] = 'many-to-one'
          // Populate /*# rel[rhs] #*/ parameter --------------------------------
          $rhs = $model->get/*# rel[lhsProperty] #*/();
          $rhsId = null;
          if ($rhs !== null) {
            $rhsId = $rhs->get/*# rel[rhsIdProperty] #*/();
            if ($rhsId === null) {
              $persister = $this->getPersister('/*# rel[rhs] #*/');
              $rhsId = $persister->create($rhs);
            }
          }
          $params[':/*# rel[lhsColumn] #*/'] = $rhsId;
          // -------------------------------------------------------------------
        #}
      #}

      $sql = $this->createSql; // If there is an exception this is handy to know
      $this->logQuery($sql, $params);
      $r = $this->create->execute($params);

      $id = $this->castId($r->getInsertId('/*# id_seq_name #*/'));
      $model->set/*# id_property #*/($id);
      $this->cache[$id] = $model;

      // TODO Figure out a way of getting sql into any exceptions
      $sql = null;
      $params = null;

      #{ each collections as col
        $this->insertCollection_/*# col[property] #*/(
          $id,
          $model->get/*# col[property] #*/()
        );
      #}

      $saveLock = SaveLock::acquire();
      $saveLock->lock($model);

      #{ each relationships as rel
        // Save related /*# rel[rhs] #*/ entities -------------------------------
        $persister = $this->getPersister('/*# rel[rhs] #*/');

        $related = $model->get/*# rel[lhsProperty] #*/();
        #{ if rel[type] = 'many-to-many'
          // If any of the related entities are new, save them to ensure that
          // they have an id, then update them.
          if ($related !== null) {
            foreach($related AS $rel) {
              if ($rel->get/*# rel[rhsIdProperty] #*/() === null) {
                $persister->save($rel);
              }
            }
          }

          // Delete all link entries for this entity
          $sql = "DELETE FROM /*# rel[linkTable] #*/
                  WHERE /*# rel[lhsLinkColumn] #*/ = :id";
          $params = array('id' => $id);
          $this->logQuery($sql, $params);
          $this->db->prepare($sql)->execute($params);

          // Create new link entries for all related entities
          if ($related !== null) {
            $sql = "INSERT INTO /*# rel[linkTable] #*/
                    (/*# rel[lhsLinkColumn] #*/, /*# rel[rhsLinkColumn] #*/)
                    VALUES (:lhsId, :rhsId)";
            $createStmt = $this->db->prepare($sql);
            foreach ($related AS $rel) {
              $params = array(
                'lhsId' => $id,
                'rhsId' => $rel->get/*# rel[rhsIdProperty] #*/()
              );
              $this->logQuery($sql, $params);
              $createStmt->execute($params);
            }
          }

        #{ elseif rel[type] = 'one-to-many'
          if ($related === null) {
            $related = array();
          }

          // Update or save the collection
          #{ if rel[mirrored]
           foreach ($related AS $rel) {
             $rel->set/*# rel[rhsProperty] #*/($model);
             $persister->save($rel);
           }
          #{ else
            foreach ($related AS $rel) {
              if ($rel->get/*# rel[rhsIdProperty] #*/() === null) {
                $persister->create($rel);
              }
            }

            $sql = "UPDATE /*# rel[rhsTable] #*/
                    SET /*# rel[rhsColumn] #*/ = :id
                    WHERE /*# rel[rhsIdColumn] #*/ = :relId";
            $updateStmt = $this->db->prepare($sql);

            foreach ($related AS $rel) {
              $params = array(
                'id' => $id,
                'relId' => $rel->get/*# rel[rhsIdProperty] #*/()
              );
              $this->logQuery($sql, $params);
              $updateStmt->execute($params);

              // Clear the cache of the RHS entity as it may contain a stale id
              $persister->clearCache($rel->get/*# rel[rhsIdProperty] #*/());
            }
          #}
        #}
        // ---------------------------------------------------------------------
      #}

      if ($startTransaction) {
        $this->db->commit();
      }

      $saveLock->release();

      #{ if onCreate
        $model->onCreate();
      #}

      return $id;
    } catch (PDOException $e) {
      $this->db->rollback();
      $model->set/*# id_property */(null);

      if (isset($saveLock)) {
        $saveLock->forceRelease();
      }

      $e = new PdoExceptionWrapper($e, '/*# class #*/');
      $e->setSql($sql, $params);
      throw $e;
    }
  }

  /**
   * Delete the given entity.
   *
   * @param /*# class #*/ $model
   */
  public function delete(\/*# class #*/ $model) {
    $id = $model->get/*# id_property #*/();
    if ($id === null) {
      throw new Exception("Can't delete /*# class_str #*/ because it does not have an id");
    }

    $params = array();
    $params[':id'] = $id;

    #{ if beforeDelete
      $model->beforeDelete();
    #}

    try {
      $startTransaction = $this->db->beginTransaction();

      $sql = $this->deleteSql; // Set SQL in case there is an exception
      $this->logQuery($sql, $params);
      $qr = $this->delete->execute($params);
      $rowCount = $qr->getRowCount();

      #{ each collections as col
        $this->removeCollection_/*# col[property] #*/($id);
      #}

      #{ each relationships AS rel
        // ---------------------------------------------------------------------
        // Delete related /*# rel[rhs] #*/ entities
        #{ if rel[type] = 'one-to-many'
          $persister = $this->getPersister('/*# rel[rhs] #*/');
          $related = $model->get/*# rel[lhsProperty] #*/();
          foreach ($related AS $rel) {
            $persister->delete($rel);
          }

        #{ elseif rel[type] = 'many-to-many'
          $sql = 'DELETE FROM /*# rel[linkTable] #*/
                  WHERE /*# rel[lhsLinkColumn] #*/ = :id';
          $params = array('id' => $id);
          $deleteStmt = $this->db->prepare($sql);
          $this->logQuery($sql, $params);
          $deleteStmt->execute($params);

        #}
        // ---------------------------------------------------------------------
      #}

      #{ if onDelete
        $model->onDelete();
      #}

      $this->cache[$id] = null;
      $model->set/*# id_property #*/(null);

      if ($startTransaction) {
        $this->db->commit();
      }

      return $rowCount;
    } catch (PDOException $e) {
      $this->db->rollback();

      $e = new PdoExceptionWrapper($e, '/*# class #*/');
      $e->setSql($sql, $params);
      throw $e;
    }
  }

  /**
   * Get the entity with the given id.  If no entity with the given id exists
   * then null is returned.
   *
   * @param integer $id
   * @return /*# class #*/
   */
  public function getById($id) {
    if (!isset($this->cache[$id])) {
      $c = new Criteria($this->queryAdapter);
      $c->addEquals('/*# id_column #*/', $id);

      // We don't care about the result since the retrieve method will
      // populate the cache
      $this->retrieve($c);

      if (!isset($this->cache[$id])) {
        return null;
      }
    }
    return $this->cache[$id];
  }

  /**
   * Retrieve a single entity that matches the given criteria.  If the criteria
   * results in more than one entity being retrieved then an exception is
   * thrown.  If the criteria results in no entities being retrieved then NULL
   * is returned
   *
   * @param Criteria $c Criteria that will result in a single entity
   * @return /*# class #*/
   * @throws Exception if the criteria results in more than one entity.
   */
  public function retrieveOne(Criteria $c) {
    $entities = $this->retrieve($c);

    $num = count($entities);
    if ($num > 1) {
      throw new Exception("Criteria maps to $num entities, expected 1");
    } else if ($num === 0) {
      return null;
    }

    return $entities[0];
  }

  /**
   * Retrieve entities that match the given criteria.  If no criteria then all
   * entities are returned.  If no entities exist or match the criteria then an
   * empty array is returned.
   *
   * @param Criteria $c
   */
  public function retrieve(Criteria $c = null) {
    if ($c === null) {
      $c = new Criteria($this->queryAdapter);
    }

    if ($c->getTable() === null) {
      $c->setTable('/*# table #*/');
    }

    // Clear the selects so that the default of all columns for the FROM table
    // are selected and ensure that only distinct entities are returned
    $c->clearSelects()
      ->setDistinct(true);
    $sql = $c->__toString();
    $params = $c->getParameters();

    try {
      $stmt = $this->db->prepare($sql);
      $this->logQuery($sql, $params);
      $qr = $stmt->execute($params);

      $result = [];
      foreach ($qr AS $row) {
        $id = $this->castId($row['/*# id_column #*/']);

        // Don't allow two instances for the same id to be created
        if (isset($this->cache[$id])) {
          $result[] = $this->cache[$id];
          continue;
        }

        $model = new \/*# class #*/();
        $model->set/*# id_property #*/($id);

        // Cache the instance before populating any relationships in order to
        // prevent inifinite loops when loading models that have a
        // relationship that is declared on both sides
        $this->cache[$id] = $model;

        // Populate the model's properties
        #{ each properties as prop
          #{ if prop[type] = 'boolean'
          $model->set/*# prop[name] #*/($row['/*# prop[col] #*/'] == 1 ? true : false);

          #{ elseif prop[type] = 'integer'
          $model->set/*# prop[name] #*/((int) $row['/*# prop[col] #*/']);

          #{ else
            $model->set/*# prop[name] #*/($row['/*# prop[col] #*/']);

          #}
        #}

        // Populate collections
        $sql = null;
        $params = null;
        #{ each collections as col
          // TODO Figure out a way of getting SQL into any exceptions
          $this->retrieveCollection_/*# col[property] #*/($id, $model);
        #}

        // Populate any relationships
        #{ each relationships as rel
          // -------------------------------------------------------------------
          // Populate the /*# rel[rhs] #*/
          #{ if rel[type] = 'one-to-many'
            $c = new Criteria($this->queryAdapter);
            $c->addEquals('/*# rel[rhsColumn] #*/', $id);
            #{ if rel[orderByCol] ISSET
              $c->addSort('/*# rel[orderByCol] #*/', '/*# rel[orderByDir] #*/');
            #{ else
              $c->addSort('/*# rel[rhsIdProperty] #*/', 'asc');
            #}

            $persister = $this->getPersister('/*# rel[rhs] #*/');
            $related = $persister->retrieve($c);
            $model->set/*# rel[lhsProperty] #*/($related);

          #{ elseif rel[type] = 'many-to-many'
            $c = new Criteria($this->queryAdapter);
            $c->addSelect('/*# rel[rhsTable] #*/.*');
            $c->addInnerJoin('/*# rel[linkTable] #*/', '/*# rel[rhsIdColumn] #*/', '/*# rel[rhsLinkColumn] #*/');
            $c->addEquals('/*# rel[lhsLinkColumn] #*/', $id);
            #{ if rel[orderByCol] ISSET
              $c->addSort('/*# rel[orderByCol] #*/', '/*# rel[orderByDir] #*/');
            #}

            $persister = $this->getPersister('/*# rel[rhs] #*/');
            $related = $persister->retrieve($c);
            $model->set/*# rel[lhsProperty] #*/($related);

          #{ elseif rel[type] = 'many-to-one'
            $relId = $row['/*# rel[lhsColumn] #*/'];
            if ($relId !== null) {
              $persister = $this->getPersister('/*# rel[rhs] #*/');
              $related = $persister->getById($relId);

              if ($related === null) {
                throw new Exception("No /*# rel[rhsStr] #*/ with id $relId.");
              }

              $model->set/*# rel[lhsProperty] #*/($related);
            }

          #}
          // -------------------------------------------------------------------
        #}

        $result[] = $model;
      }

      return $result;
    } catch (PDOException $e) {
      $e = new PdoExceptionWrapper($e, '/*# class #*/');
      $e->setSql($sql, $params);
      throw $e;
    }
  }

  /**
   * Saves the given instance by either creating it if it does not have an ID or
   * updating if it does.
   *
   * @param ${class} $model
   */
  public function save(\/*# class #*/ $model) {
    $id = $model->get/*# id_property #*/();
    if ($id === null) {
      $this->create($model);
    } else {
      $this->update($model);
    }
  }

  /**
   * Update the given entity.
   *
   * @param ${class} $model
   */
  public function update(\/*# class #*/ $model) {
    $id = $model->get/*# id_property #*/();
    if ($id === null) {
      throw new Exception("Can't update /*# class_str #*/ because it does not have an id");
    }

    if (SaveLock::isLocked($model)) {
      return;
    }

    $validator = $this->getValidator('/*# class #*/');
    if (!$validator->validate($model, $e)) {
      throw $e;
    }

    #{ if beforeUpdate
      $model->beforeUpdate();
    #}

    try {
      $startTransaction = $this->db->beginTransaction();

      $saveLock = SaveLock::acquire();
      $saveLock->lock($model);

      $params = Array();
      $params[':id'] = $id;
      #{ each properties as prop
        #{ if prop[type] = 'boolean'
          $params[':/*# prop[col] #*/'] = $model->get/*# prop[name] #*/() ? 1 : 0;
        #{ else
          $params[':/*# prop[col] #*/'] = $model->get/*# prop[name] #*/();
        #}
      #}

      #{ each relationships as rel

        #{ if rel[type] = 'many-to-one'
          // Populate /*# rel[rhs] #*/ parameter
          $rhs = $model->get/*# rel[lhsProperty] #*/();
          $rhsId = null;
          if ($rhs !== null) {
            $rhsId = $rhs->get/*# rel[rhsIdProperty] #*/();
            if ($rhsId === null) {
              $persister = $this->getPersister('/*# rel[rhs] #*/');
              $rhsId = $persister->create($rhs);
            }
          }
          $params[':/*# rel[lhsColumn] #*/'] = $rhsId;
        #}

      #}

      #{ if has_update
        $sql = $this->updateSql;
        $this->logQuery($sql, $params);
        $qr = $this->update->execute($params);
        $rowCount = $qr->getRowCount();
      #}

      #-- Update each of the model's collections by first removing the existing
      #-- persisted collection and replacing it with what is in the model
      // TODO Figure out a way of getting the SQL and params into any exception
      $sql = null;
      $params = null;
      #{ each collections as col
          $this->removeCollection_/*# col[property] #*/($id);
          $this->insertCollection_/*# col[property] #*/($id, $model->get/*# col[property] #*/());
      #}


      #{ each relationships as rel
        // ---------------------------------------------------------------------
        // Save related /*# rel[rhs] #*/ entities
        $persister = $this->getPersister('/*# rel[rhs] #*/');

        #{ if rel[type] = 'many-to-many'
          // If any of the related entities are new, save them to ensure that
          // they have an id, then update them.
          $related = $model->get/*# rel[lhsProperty] #*/();
          if ($related !== null) {
            foreach($related AS $rel) {
              if ($rel->get/*# rel[rhsIdProperty] #*/() === null) {
                $persister->save($rel);
              }
            }
          }

          // Delete all link entries for this entity
          $sql = "DELETE FROM /*# rel[linkTable] #*/ WHERE /*# rel[lhsLinkColumn] #*/ = :id";
          $params = array('id' => $id);
          $deleteStmt = $this->db->prepare($sql);
          $this->logQuery($sql, $params);
          $deleteStmt->execute($params);

          // Create new link entries for all related entities
          if ($related !== null) {
            $sql = "INSERT INTO /*# rel[linkTable] #*/ (/*# rel[lhsLinkColumn] #*/, /*# rel[rhsLinkColumn] #*/) VALUES (:lhsId, :rhsId)";
            $createStmt = $this->db->prepare($sql);
            foreach ($related AS $rel) {
              $params = array(
                'lhsId' => $id,
                'rhsId' => $rel->get/*# rel[rhsIdProperty] #*/()
              );
              $this->logQuery($sql, $params);
              $createStmt->execute($params);
            }
          }

        #{ elseif rel[type] = 'one-to-many'
          $related = $model->get/*# rel[lhsProperty] #*/();
          if ($related === null) {
            $related = array();
          }

          $relIds = array();
          foreach ($related AS $rel) {
            $relIds[] = $rel->get/*# rel[rhsIdProperty] #*/();
          }

          $c = new Criteria($this->queryAdapter);
          $c->addEquals('/*# rel[rhsColumn] #*/', $id);
          $current = $persister->retrieve($c);

          // Update or save the collection
          #{ if rel[mirrored]
            foreach ($related AS $rel) {
              $rel->set/*# rel[rhsProperty] #*/($model);
              $persister->save($rel);
            }
            foreach ($current AS $cur) {
              if (!in_array($cur->get/*# rel[rhsIdProperty] #*/(), $relIds)) {
                #{ if rel[deleteOrphan]
                  $persister->delete($cur);
                #}
              }
            }
          #{ else
            foreach ($related AS $rel) {
              if ($rel->get/*# rel[rhsIdProperty] #*/() === null) {
                $persister->create($rel);
              }
            }

            $sql = "UPDATE /*# rel[rhsTable] #*/ SET /*# rel[rhsColumn] #*/ = :id WHERE /*# rel[rhsIdColumn] #*/ = :relId";
            $updateStmt = $this->db->prepare($sql);
            foreach ($related AS $rel) {
              $params = array(
                'id' => $id,
                'relId' => $rel->get/*# rel[rhsIdProperty] #*/()
              );
              $this->logQuery($sql, $params);
              $updateStmt->execute($params);

              // Clear the cache of the RHS entity as it may contain a stale id
              $persister->clearCache($rel->get/*# rel[rhsIdProperty] #*/());
            }

            #{ if rel[deleteOrphan]
              $sql = "DELETE FROM /*# rel[rhsTable] #*/ WHERE /*# rel[rhsIdColumn] #*/ = :relId";
              $orphanStmt = $this->db->prepare($sql);
            #{ else
              $sql = "UPDATE /*# rel[rhsTable] #*/ SET /*# rel[rhsColumn] #*/ = null WHERE /*# rel[rhsIdColumn] #*/ = :relId";
              $orphanStmt = $this->db->prepare($sql);
            #}
            foreach ($current AS $cur) {
              if (!in_array($cur->get/*# rel[rhsIdProperty] #*/(), $relIds)) {
                $params = array('relId' => $cur->get/*# rel[rhsIdProperty] #*/());
                $this->logQuery($sql, $params);
                $orphanStmt->execute($params);
              }

              $persister->clearCache($rel->get/*# rel[rhsIdProperty] #*/());
            }
          #}
        #}
        // ---------------------------------------------------------------------
      #}

      $saveLock->release();

      if ($startTransaction) {
        $this->db->commit();
      }

      #{ if onUpdate
        $model->onUpdate();
      #}

      #{ if has_update
        return $rowCount;
      #{ else
        return 1;
      #}
    } catch (PDOException $e) {
      $this->db->rollback();
      $saveLock->forceRelease();

      $e = new PdoExceptionWrapper($e, '/*# class #*/');
      $e->setSql($sql, $params);
      throw $e;
    }
  }

  /*
   * ================================================================================
   * Private Helpers
   * ================================================================================
   */

  private function castId($id) {
    #{ if id_type = 'integer'
      return (int) $id;
    #}{ else
      return $id;
    #}
  }

  #-- Create methods for removing each of the model's collections
  #{ each collections as col
    private function removeCollection_/*# col[property] #*/($id) {
      $sql = 'DELETE FROM /*# col[link] #*/ WHERE /*# col[idCol] #*/ = :id';
      $params = array('id' => $id);
      $this->logQuery($sql, $params);
      $this->db->prepare($sql)->execute($params);
    }
  #}

  #-- Create methods for persisting each of the model's collections
  #{ each collections as col
    private function insertCollection_/*# col[property] #*/($id, $collection) {
      #{ if col[type] = 'set'
        $sql =
          "INSERT INTO /*# col[link] #*/
           (/*# collection[idCol] #*/, /*# col[valCol] #*/)
           VALUES (:id, :val)";
        $stmt = $this->db->prepare($sql);

        // TODO Update this to use bulk insert
        foreach ($collection as $val) {
          $params = array(
            'id' => $id,
            'val' => $val
          );
          $this->logQuery($sql, $params);
          $stmt->execute($params);
        }

      #{ elseif col[type] = 'list'
        $sql =
          "INSERT INTO /*# col[link] #*/
           (/*# col[idCol] #*/, /*# col[valCol] #*/, /*# col[seqCol] #*/)
           VALUES (:id, :val, :seq)";
        $stmt = $this->db->prepare($sql);

        // TODO Update this to use bulk insert
        foreach ($collection as $seq => $val) {
          $params = array(
            'id' => $id,
            'val' => $val,
            'seq' => $seq
          );
          $this->logQuery($sql, $params);
          $stmt->execute($params);
        }

      #{ elseif col[type] = 'map'
        $sql =
          "INSERT INTO /*# col[link] #*/
           (/*# col[idCol] #*/, /*# col[keyCol] #*/, /*# col[valCol] #*/)
           VALUES (:id, :key, :val)";
        $stmt = $this->db->prepare($sql);

        // TODO Update this to use bulk insert
        foreach ($collection as $key => $val) {
          $params = array(
            'id' => $id,
            'key' => $key,
            'val' => $val
          );
          $this->logQuery($sql, $params);
          $stmt->execute($params);
        }

      #}
    }
  #}

  #-- Create methods for retrieve each of the model's collections
  #{ each  collections as col
    private function retrieveCollection_/*# col[property] #*/($id, $model) {
      #{ if col[type] = 'set'
        $sql = 'SELECT /*# col[valCol] #*/ FROM /*# col[link] #*/ WHERE /*# col[idCol] #*/ = :id';
        $params = array('id' => $id);
        $this->logQuery($sql, $params);
        $qr = $this->db->prepare($sql)->execute($params);

        $collection = array();
        foreach ($qr as $row) {
          $collection[] = $row['/*# col[valCol] #*/'];
        }
        $model->set/*# col[property] #*/($collection);

      #{ elseif col[type] = 'list'
        $sql =
          'SELECT /*# col[valCol] #*/ FROM /*# col[link] #*/
          WHERE /*# col[idCol] #*/ = :id
          ORDER BY /*# col[seqCol] #*/';
        $params = array('id' => $id);
        $this->logQuery($sql, $params);
        $qr = $this->db->prepare($sql)->execute($params);

        $collection = array();
        foreach ($qr as $row) {
          $collection[] = $row['/*# col[valCol] #*/'];
        }
        $model->set/*# col[property] #*/($collection);

      #{ elseif col[type] = 'map'
        $sql =
          'SELECT /*# col[keyCol] #*/, /*# col[valCol] #*/
           FROM /*# col[link] #*/
           WHERE /*# col[idCol] #*/ = :id';
        $params = array('id' => $id);
        $this->logQuery($sql, $params);
        $qr = $this->db->prepare($sql)->execute($params);

        $collection = array();
        foreach ($qr as $row) {
          $collection[$row['/*# col[keyCol] #*/']] = $row['/*# col[valCol] #*/'];
        }
        $model->set/*# col[property] #*/($collection);

      #}
    }
  #}
}
